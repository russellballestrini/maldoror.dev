import { z } from 'zod';

// ============================================
// LEGACY ASCII SPRITE SCHEMAS (kept for compatibility)
// ============================================

/**
 * Schema for a single sprite cell (ASCII mode)
 */
export const SpriteCellSchema = z.object({
  char: z.string().length(1).describe('ASCII character for this cell'),
  fg: z.string().regex(/^#[0-9a-fA-F]{6}$/).optional().describe('Foreground color as hex (e.g., #FF0000)'),
  bg: z.string().regex(/^#[0-9a-fA-F]{6}$/).optional().describe('Background color as hex (e.g., #000000)'),
});

/**
 * Schema for a single animation frame (7x12 grid) - ASCII mode
 */
export const SpriteFrameSchema = z.array(
  z.array(SpriteCellSchema).length(7).describe('Row of 7 cells')
).length(12).describe('12 rows making a 7x12 sprite');

/**
 * Schema for all directional frames - ASCII mode
 */
export const DirectionalFramesSchema = z.object({
  up: z.array(SpriteFrameSchema).length(4).describe('4 animation frames for facing up'),
  down: z.array(SpriteFrameSchema).length(4).describe('4 animation frames for facing down'),
  left: z.array(SpriteFrameSchema).length(4).describe('4 animation frames for facing left'),
  right: z.array(SpriteFrameSchema).length(4).describe('4 animation frames for facing right'),
});

/**
 * Schema for complete sprite data - ASCII mode
 */
export const SpriteGridSchema = z.object({
  width: z.literal(7).describe('Sprite width in characters'),
  height: z.literal(12).describe('Sprite height in characters'),
  frames: DirectionalFramesSchema,
});

// ============================================
// PIXEL SPRITE SCHEMAS (16x24 RGB)
// ============================================

/**
 * Schema for RGB color (0-255 per channel)
 */
export const RGBSchema = z.object({
  r: z.number().int().min(0).max(255).describe('Red channel 0-255'),
  g: z.number().int().min(0).max(255).describe('Green channel 0-255'),
  b: z.number().int().min(0).max(255).describe('Blue channel 0-255'),
});

/**
 * Schema for a single pixel with transparency support
 * Using explicit t flag instead of nullable to avoid OpenAI schema issues
 */
export const PixelSchema = z.object({
  r: z.number().int().min(0).max(255).describe('Red channel 0-255'),
  g: z.number().int().min(0).max(255).describe('Green channel 0-255'),
  b: z.number().int().min(0).max(255).describe('Blue channel 0-255'),
  t: z.boolean().describe('True if transparent (ignore RGB values)'),
}).describe('Pixel with RGB color and transparency flag');

/**
 * Schema for a pixel grid row (16 pixels wide)
 */
export const PixelRowSchema = z.array(PixelSchema).length(16).describe('Row of 16 pixels');

/**
 * Schema for a single pixel frame (16x24 grid)
 */
export const PixelFrameSchema = z.array(PixelRowSchema).length(24).describe('24 rows of 16 pixels each');

/**
 * Schema for 1 animation frame per direction (standing pose only)
 * Walking frames are generated by duplicating the standing pose
 */
export const PixelDirectionFramesSchema = z.array(PixelFrameSchema)
  .length(1)
  .describe('1 animation frame: [standing]');

/**
 * Schema for all directional frames - Pixel mode
 */
export const PixelDirectionalFramesSchema = z.object({
  up: PixelDirectionFramesSchema.describe('4 frames for facing up (back view)'),
  down: PixelDirectionFramesSchema.describe('4 frames for facing down (front view)'),
  left: PixelDirectionFramesSchema.describe('4 frames for facing left'),
  right: PixelDirectionFramesSchema.describe('4 frames for facing right'),
});

/**
 * Schema for complete pixel sprite data (16x24)
 */
export const PixelSpriteSchema = z.object({
  width: z.literal(16).describe('Sprite width in pixels'),
  height: z.literal(24).describe('Sprite height in pixels'),
  frames: PixelDirectionalFramesSchema,
});

// ============================================
// COMPACT PIXEL SPRITE SCHEMAS (string-based)
// ============================================

/**
 * Compact format: each pixel is "RRRGGGBBBt" or "RRRGGGBBBf" (10 chars)
 * Or just "0" for transparent (shorthand for "000000000t")
 * Example: "255000000f" = red pixel, "0" = transparent
 * Rows are arrays of these strings, frames are arrays of rows
 */
export const CompactPixelSchema = z.string()
  .describe('Pixel as RRRGGGBBB + t/f (e.g., "255000000f" for red) or "0" for transparent');

export const CompactRowSchema = z.array(CompactPixelSchema)
  .describe('Row of pixels in compact format');

export const CompactFrameSchema = z.array(CompactRowSchema)
  .describe('Frame as array of rows');

export const CompactDirectionalFramesSchema = z.object({
  up: CompactFrameSchema.describe('Frame for facing up (back view)'),
  down: CompactFrameSchema.describe('Frame for facing down (front view)'),
  left: CompactFrameSchema.describe('Frame for facing left'),
  right: CompactFrameSchema.describe('Frame for facing right'),
});

export const CompactPixelSpriteSchema = z.object({
  width: z.number().describe('Sprite width in pixels (16)'),
  height: z.number().describe('Sprite height in pixels (24)'),
  frames: CompactDirectionalFramesSchema,
});

// Debug pixel for padding incomplete data (bright green)
export const DEBUG_PIXEL = { r: 0, g: 255, b: 0, t: false };
// Transparent pixel
export const TRANSPARENT_PIXEL = { r: 0, g: 0, b: 0, t: true };

/**
 * Parse compact pixel string to pixel object
 * Supports: "0" for transparent, "RRRGGGBBBt/f" for full format
 */
export function parseCompactPixel(s: string): { r: number; g: number; b: number; t: boolean } {
  if (!s) {
    return DEBUG_PIXEL;
  }

  // "0" is shorthand for transparent
  if (s === '0') {
    return TRANSPARENT_PIXEL;
  }

  if (s.length !== 10) {
    return DEBUG_PIXEL;
  }

  const r = parseInt(s.slice(0, 3), 10);
  const g = parseInt(s.slice(3, 6), 10);
  const b = parseInt(s.slice(6, 9), 10);
  const t = s[9] === 't';

  if (isNaN(r) || isNaN(g) || isNaN(b)) {
    return DEBUG_PIXEL;
  }
  return { r, g, b, t };
}

/**
 * Parse compact frame to full pixel frame, padding with debug pixels if needed
 */
export function parseCompactFrame(rows: string[][], width = 16, height = 24): Array<Array<{ r: number; g: number; b: number; t: boolean }>> {
  const frame: Array<Array<{ r: number; g: number; b: number; t: boolean }>> = [];

  for (let y = 0; y < height; y++) {
    const row: Array<{ r: number; g: number; b: number; t: boolean }> = [];
    const srcRow = rows[y] || [];

    for (let x = 0; x < width; x++) {
      const pixel = srcRow[x];
      row.push(pixel ? parseCompactPixel(pixel) : DEBUG_PIXEL);
    }
    frame.push(row);
  }

  return frame;
}

export type CompactPixelSprite = z.infer<typeof CompactPixelSpriteSchema>;

// ============================================
// TYPE EXPORTS
// ============================================

// ASCII types (legacy)
export type SpriteCell = z.infer<typeof SpriteCellSchema>;
export type SpriteFrame = z.infer<typeof SpriteFrameSchema>;
export type DirectionalFrames = z.infer<typeof DirectionalFramesSchema>;
export type SpriteGrid = z.infer<typeof SpriteGridSchema>;

// Pixel types
export type RGB = z.infer<typeof RGBSchema>;
export type Pixel = z.infer<typeof PixelSchema>;
export type PixelFrame = z.infer<typeof PixelFrameSchema>;
export type PixelDirectionalFrames = z.infer<typeof PixelDirectionalFramesSchema>;
export type PixelSprite = z.infer<typeof PixelSpriteSchema>;
